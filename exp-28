import numpy as np
from sympy import mod_inverse

def text_to_numbers(text):
    return [ord(c) - ord('a') for c in text.lower() if c.isalpha()]

def numbers_to_text(numbers):
    return ''.join(chr(n % 26 + ord('a')) for n in numbers)

def pad_text(text):
    if len(text) % 2 != 0:
        text += 'x'
    return text

def encrypt_hill(plaintext, key):
    plaintext = pad_text(plaintext)
    nums = text_to_numbers(plaintext)
    ciphertext = []
    for i in range(0, len(nums), 2):
        pair = np.array([nums[i], nums[i+1]])
        enc = np.dot(key, pair) % 26
        ciphertext.extend(enc.flatten())
    return numbers_to_text(ciphertext)

def decrypt_hill(ciphertext, key):
    det = int(np.round(np.linalg.det(key))) % 26
    det_inv = mod_inverse(det, 26)
    if det_inv is None:
        raise ValueError("Key matrix is not invertible mod 26")
    adj = np.array([[key[1][1], -key[0][1]], [-key[1][0], key[0][0]]])
    inv_key = (det_inv * adj) % 26
    nums = text_to_numbers(ciphertext)
    plaintext = []
    for i in range(0, len(nums), 2):
        pair = np.array([nums[i], nums[i+1]])
        dec = np.dot(inv_key, pair) % 26
        plaintext.extend(dec.flatten())
    return numbers_to_text(plaintext)

# Key matrix
key = np.array([[9, 4], [5, 7]])

# Message
plaintext = "meet me at the usual place at ten rather than eight oclock"
ciphertext = encrypt_hill(plaintext, key)
decrypted = decrypt_hill(ciphertext, key)

print("Original plaintext:\n", plaintext)
print("\nEncrypted ciphertext:\n", ciphertext)
print("\nDecrypted plaintext:\n", decrypted)
